




Ei tg bot ta kivabe specific email and link find kortese dekho to: 1st file: import os
import json
import asyncio
import re
from datetime import datetime, timedelta
from dotenv import load_dotenv
from telegram import Bot
from imap_tools import MailBox, AND
from deep_translator import GoogleTranslator
from langdetect import detect

# Load environment variables
load_dotenv()
EMAIL = os.getenv("EMAIL_ADDRESS")
PASSWORD = os.getenv("EMAIL_PASSWORD")
SERVER = os.getenv("EMAIL_SERVER")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

WATCHLIST_FILE = "watchlist.json"
bot = Bot(token=TELEGRAM_TOKEN)

# Settings
SLEEP_INTERVAL = 0.2         # Polling interval in seconds
ATTEMPT1_LIMIT = 10          # First attempt: fetch latest 10 emails
ATTEMPT2_LIMIT = 25          # Retry: fetch latest 25 emails

# For code filter, we use a keyword list (others use inline matching)
CODE_KEYWORDS = ["sign in code", "login code", "code"]

# Fuzzy keyword lists for matching (for reset and temp filters)
RESET_KEYWORDS = ["password", "reset", "replacement"]
TEMP_KEYWORDS = ["temporary", "household"]

# Global persistent mailbox connection variable
persistent_mailbox = None

def log(message):
    """Log a timestamped message to the terminal."""
    now = datetime.now().strftime("%H:%M:%S")
    print(f"[{now}] {message}")

def get_mailbox():
    """Return a persistent mailbox connection (logging in if needed)."""
    global persistent_mailbox
    if persistent_mailbox is None:
        try:
            persistent_mailbox = MailBox(SERVER)
            persistent_mailbox.login(EMAIL, PASSWORD)
            log("Connected to IMAP server (persistent connection).")
        except Exception as e:
            log(f"‚ùå Error connecting to mailbox: {e}")
            persistent_mailbox = None
    return persistent_mailbox

def reset_mailbox():
    """Logs out and resets the persistent mailbox connection."""
    global persistent_mailbox
    try:
        if persistent_mailbox:
            persistent_mailbox.logout()
    except Exception:
        pass
    persistent_mailbox = None
    log("Mailbox connection reset.")

def load_watchlist():
    """Load the client watchlist from file."""
    if os.path.exists(WATCHLIST_FILE):
        with open(WATCHLIST_FILE, "r") as f:
            return json.load(f)
    return {}

def save_watchlist(data):
    """Save (or clear) the watchlist."""
    with open(WATCHLIST_FILE, "w") as f:
        json.dump(data, f)

async def send_message(chat_id, text):
    try:
        message = await bot.send_message(chat_id=int(chat_id), text=text, parse_mode="HTML")
        return message
    except Exception as e:
        log(f"‚ùå Telegram error for chat {chat_id}: {e}")

async def update_message(chat_id, message_id, text):
    try:
        await bot.edit_message_text(chat_id=int(chat_id), message_id=message_id, text=text, parse_mode="HTML")
    except Exception as e:
        log(f"‚ùå Error updating message {message_id} for chat {chat_id}: {e}")

async def async_translate_text(text):
    """Translate text to English asynchronously using deep-translator."""
    try:
        translated = await asyncio.to_thread(lambda: GoogleTranslator(source='auto', target='en').translate(text))
        return translated
    except Exception as e:
        log(f"Translation error: {e}")
        return text

async def check_match_async(msg, alert_type):
    """
    Asynchronously translate the message's subject (if non-English) and use fuzzy matching.
    """
    original_subject = msg.subject or ""
    try:
        subj_lang = detect(original_subject) if original_subject.strip() else "en"
    except Exception:
        subj_lang = "en"

    if subj_lang != "en":
        translated_subject = await async_translate_text(original_subject)
        log(f"Translated subject (from {subj_lang}): {translated_subject}")
    else:
        translated_subject = original_subject

    # Wrap the translated subject into a fake message object for matching.
    class FakeMsg:
        subject = translated_subject
        text = msg.text or ""
    return check_match(FakeMsg, alert_type)

def extract_code(text):
    match = re.search(r"\b\d{4,8}\b", text)
    return match.group(0) if match else None

def extract_link(text):
    matches = re.findall(r"https?://\S+", text)
    for link in matches:
        if "netflix" in link.lower():
            return link
    return matches[0] if matches else None

def extract_temp_link(text):
    match = re.search(r"https://www\.netflix\.com/account\S+", text)
    return match.group(0) if match else None

async def fetch_emails(limit):
    """
    Fetch the latest `limit` emails from the past day using the persistent mailbox.
    Logs each email's subject to the terminal.
    """
    threshold = (datetime.now() - timedelta(days=1)).date()
    def _fetch():
        mailbox = get_mailbox()
        if mailbox is None:
            raise Exception("No mailbox connection.")
        try:
            msgs = mailbox.fetch(AND(date_gte=threshold), limit=limit, reverse=True)
            messages = list(msgs)
            for m in messages:
                log(f"Fetched email: {m.subject}")
            return messages
        except Exception as e:
            log(f"‚ùå Fetch error: {e}. Resetting mailbox...")
            reset_mailbox()
            raise e
    try:
        emails = await asyncio.to_thread(_fetch)
        log(f"Fetched {len(emails)} emails (limit={limit}).")
        return emails
    except Exception as e:
        await asyncio.sleep(0.1)
        return await asyncio.to_thread(_fetch)

def group_emails_by_recipient(emails):
    """
    Group emails by the first recipient (converted to lower case).
    Returns a dictionary: { recipient_email: [msg, ...] }
    """
    groups = {}
    for msg in emails:
        if msg.to and len(msg.to) > 0:
            recipient = msg.to[0].lower()
            groups.setdefault(recipient, []).append(msg)
    return groups

def check_match(msg, alert_type):
    """
    Fuzzy matching for different alert types:
      - For "reset": returns True if the subject contains "password" and one of ["reset", "replacement"]
        and the email body has a Netflix link.
      - For "temp": returns True if the subject contains any word from TEMP_KEYWORDS and the body contains a temporary link.
      - For "code": returns True if the subject contains any word from CODE_KEYWORDS and the body contains a code.
    """
    subject = (msg.subject or "").lower()
    body = msg.text or ""
    if alert_type == "reset":
        if "password" in subject and any(kw in subject for kw in ["reset", "replacement"]) and extract_link(body):
            return True
    elif alert_type == "temp":
        if any(kw in subject for kw in TEMP_KEYWORDS) and extract_temp_link(body):
            return True
    elif alert_type == "code":
        if any(kw in subject for kw in CODE_KEYWORDS) and extract_code(body):
            return True
    return False

def get_result(msg, alert_type):
    """
    Extract and return the result (Netflix link or code) from the message.
    """
    body = msg.text or ""
    if alert_type == "reset":
        link = extract_link(body)
        if link:
            return f"üîó <b>Netflix Link:</b>\n{link}"
    elif alert_type == "temp":
        link = extract_temp_link(body)
        if link:
            return f"üîó <b>Netflix Link:</b>\n{link}"
    elif alert_type == "code":
        code = extract_code(body)
        if code:
            return f"üîë <b>Netflix Code:</b>\n<code>{code}</code>"
    return None

async def process_watchlist(attempt1_emails):
    """
    Process the watchlist by scanning each user‚Äôs emails from the shared ATTEMPT1 batch.
    For each user that does not match on attempt 1, schedule a retry.
    Returns a list of retry requests to be processed later.
    Each retry item is a tuple of (chat_id, user_email, alert_type, progress_msg, retry_start_time).
    """
    watchlist = load_watchlist()
    retry_requests = []
    for chat_id, user_data in watchlist.items():
        user_email = user_data["email"]
        # Determine the alert type based on provided filters.
        if "reset" in user_data["filters"]:
            alert_type = "reset"
        elif "temp" in user_data["filters"]:
            alert_type = "temp"
        else:
            alert_type = "code"
        start_time = datetime.now()
        progress_msg = await send_message(
            chat_id,
            f"‚è± [Attempt 1] Scanning {ATTEMPT1_LIMIT} emails for <b>{alert_type}</b> filter for <b>{user_email}</b>..."
        )
        groups1 = group_emails_by_recipient(attempt1_emails)
        user_msgs1 = groups1.get(user_email.lower(), [])
        total1 = len(user_msgs1)
        matched = False
        count = 0
        for msg in user_msgs1:
            count += 1
            elapsed = (datetime.now() - start_time).total_seconds()
            await update_message(chat_id, progress_msg.message_id,
                                 f"[Attempt 1] Processed {count}/{total1} emails for <b>{user_email}</b> (Elapsed: {elapsed:.1f}s)...")
            if await check_match_async(msg, alert_type):
                result = get_result(msg, alert_type)
                if result:
                    elapsed = (datetime.now() - start_time).total_seconds()
                    await update_message(chat_id, progress_msg.message_id,
                                         f"‚úÖ Match found in Attempt 1 (Elapsed: {elapsed:.1f}s):\n{result}")
                    log(f"User {user_email}: Match found in Attempt 1 after {elapsed:.1f}s.")
                    matched = True
                    break
        if not matched:
            await update_message(chat_id, progress_msg.message_id,
                                 f"‚ùå No match in Attempt 1 for <b>{user_email}</b>. Initiating retry...")
            log(f"User {user_email}: No match in Attempt 1, scheduled for retry.")
            # Record the request for retry processing.
            retry_requests.append((chat_id, user_email, alert_type, progress_msg, datetime.now()))
    # Clear the watchlist after processing attempt 1.
    save_watchlist({})
    return retry_requests

async def process_retries(retry_requests):
    """
    For all users scheduled for retry, fetch the latest ATTEMPT2_LIMIT emails once,
    then scan each user (using the shared set of attempt2 emails) so that if many users
    have emails in this batch, they all get updated instantly.
    """
    if not retry_requests:
        return
    attempt2_emails = await fetch_emails(ATTEMPT2_LIMIT)
    groups2 = group_emails_by_recipient(attempt2_emails)
    for chat_id, user_email, alert_type, progress_msg, retry_start in retry_requests:
        user_msgs2 = groups2.get(user_email.lower(), [])
        if user_msgs2:
            latest_msg = user_msgs2[0]
            await update_message(chat_id, progress_msg.message_id,
                                 f"[Attempt 2] Scanning the most recent email for <b>{user_email}</b>...")
            if await check_match_async(latest_msg, alert_type):
                result = get_result(latest_msg, alert_type)
                elapsed_retry = (datetime.now() - retry_start).total_seconds()
                if result:
                    await update_message(chat_id, progress_msg.message_id,
                                         f"‚úÖ Match found in Retry (Elapsed: {elapsed_retry:.1f}s):\n{result}")
                    log(f"User {user_email}: Match found in Attempt 2 (Retry) after {elapsed_retry:.1f}s.")
                else:
                    await update_message(chat_id, progress_msg.message_id,
                                         f"‚ùå No valid Netflix {alert_type} email found for <b>{user_email}</b> in Retry.")
                    log(f"User {user_email}: No match found in Retry.")
            else:
                await update_message(chat_id, progress_msg.message_id,
                                     f"‚ùå No valid Netflix {alert_type} email found for <b>{user_email}</b> in Retry.")
                log(f"User {user_email}: No match found in Retry.")
        else:
            await update_message(chat_id, progress_msg.message_id,
                                 f"‚ö†Ô∏è No emails found for <b>{user_email}</b> in Retry.")
            log(f"User {user_email}: No emails in Attempt 2.")

async def main():
    log("üöÄ Netflix multi-user advanced watcher started with optimized retry processing.")
    while True:
        try:
            # Fetch the latest ATTEMPT1_LIMIT emails (from the past day).
            attempt1_emails = await fetch_emails(ATTEMPT1_LIMIT)
            log(f"Shared ATTEMPT 1 emails fetched: {len(attempt1_emails)}")
            for email in attempt1_emails:
                log(f"Email subject: {email.subject}")
            
            # Process watchlist for attempt 1.
            retry_requests = await process_watchlist(attempt1_emails)
            
            # Process all retry requests concurrently using a single shared attempt 2 fetch.
            await process_retries(retry_requests)
        except Exception as e:
            log(f"‚ùó Error in main loop: {e}")
            reset_mailbox()
        # Wait for a short interval before polling again.
        await asyncio.sleep(SLEEP_INTERVAL)

if __name__ == "__main__":
    asyncio.run(main())

2nd file: import os
import json
import asyncio
import re
from datetime import datetime, timedelta
from dotenv import load_dotenv
from telegram import Bot
from imap_tools import MailBox, AND
from deep_translator import GoogleTranslator
from langdetect import detect

# Load environment variables
load_dotenv()
EMAIL = os.getenv("EMAIL_ADDRESS")
PASSWORD = os.getenv("EMAIL_PASSWORD")
SERVER = os.getenv("EMAIL_SERVER")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

WATCHLIST_FILE = "watchlist.json"
bot = Bot(token=TELEGRAM_TOKEN)

# Settings
SLEEP_INTERVAL = 0.2         # Polling interval in seconds
ATTEMPT1_LIMIT = 10          # First attempt: fetch latest 10 emails
ATTEMPT2_LIMIT = 25          # Retry: fetch latest 25 emails

# For code filter, we use a keyword list (others use inline matching)
CODE_KEYWORDS = ["sign in code", "login code", "code"]

# Fuzzy keyword lists for matching (for reset and temp filters)
RESET_KEYWORDS = ["password", "reset", "replacement"]
TEMP_KEYWORDS = ["temporary", "household"]

# Global persistent mailbox connection variable
persistent_mailbox = None

def log(message):
    """Log a timestamped message to the terminal."""
    now = datetime.now().strftime("%H:%M:%S")
    print(f"[{now}] {message}")

def get_mailbox():
    """Return a persistent mailbox connection (logging in if needed)."""
    global persistent_mailbox
    if persistent_mailbox is None:
        try:
            persistent_mailbox = MailBox(SERVER)
            persistent_mailbox.login(EMAIL, PASSWORD)
            log("Connected to IMAP server (persistent connection).")
        except Exception as e:
            log(f"‚ùå Error connecting to mailbox: {e}")
            persistent_mailbox = None
    return persistent_mailbox

def reset_mailbox():
    """Logs out and resets the persistent mailbox connection."""
    global persistent_mailbox
    try:
        if persistent_mailbox:
            persistent_mailbox.logout()
    except Exception:
        pass
    persistent_mailbox = None
    log("Mailbox connection reset.")

def load_watchlist():
    """Load the client watchlist from file."""
    if os.path.exists(WATCHLIST_FILE):
        with open(WATCHLIST_FILE, "r") as f:
            return json.load(f)
    return {}

def save_watchlist(data):
    """Save (or clear) the watchlist."""
    with open(WATCHLIST_FILE, "w") as f:
        json.dump(data, f)

async def send_message(chat_id, text):
    try:
        message = await bot.send_message(chat_id=int(chat_id), text=text, parse_mode="HTML")
        return message
    except Exception as e:
        log(f"‚ùå Telegram error for chat {chat_id}: {e}")

async def update_message(chat_id, message_id, text):
    try:
        await bot.edit_message_text(chat_id=int(chat_id), message_id=message_id, text=text, parse_mode="HTML")
    except Exception as e:
        log(f"‚ùå Error updating message {message_id} for chat {chat_id}: {e}")

async def async_translate_text(text):
    """Translate text to English asynchronously using deep-translator."""
    try:
        translated = await asyncio.to_thread(lambda: GoogleTranslator(source='auto', target='en').translate(text))
        return translated
    except Exception as e:
        log(f"Translation error: {e}")
        return text

async def check_match_async(msg, alert_type):
    """
    Asynchronously translate the message's subject (if non-English) and use fuzzy matching.
    """
    original_subject = msg.subject or ""
    try:
        subj_lang = detect(original_subject) if original_subject.strip() else "en"
    except Exception:
        subj_lang = "en"

    if subj_lang != "en":
        translated_subject = await async_translate_text(original_subject)
        log(f"Translated subject (from {subj_lang}): {translated_subject}")
    else:
        translated_subject = original_subject

    # Wrap the translated subject into a fake message object for matching.
    class FakeMsg:
        subject = translated_subject
        text = msg.text or ""
    return check_match(FakeMsg, alert_type)

def extract_code(text):
    match = re.search(r"\b\d{4,8}\b", text)
    return match.group(0) if match else None

def extract_link(text):
    matches = re.findall(r"https?://\S+", text)
    for link in matches:
        if "netflix" in link.lower():
            return link
    return matches[0] if matches else None

def extract_temp_link(text):
    match = re.search(r"https://www\.netflix\.com/account\S+", text)
    return match.group(0) if match else None

async def fetch_emails(limit):
    """
    Fetch the latest `limit` emails from the past day using the persistent mailbox.
    Logs each email's subject to the terminal.
    """
    threshold = (datetime.now() - timedelta(days=1)).date()
    def _fetch():
        mailbox = get_mailbox()
        if mailbox is None:
            raise Exception("No mailbox connection.")
        try:
            msgs = mailbox.fetch(AND(date_gte=threshold), limit=limit, reverse=True)
            messages = list(msgs)
            for m in messages:
                log(f"Fetched email: {m.subject}")
            return messages
        except Exception as e:
            log(f"‚ùå Fetch error: {e}. Resetting mailbox...")
            reset_mailbox()
            raise e
    try:
        emails = await asyncio.to_thread(_fetch)
        log(f"Fetched {len(emails)} emails (limit={limit}).")
        return emails
    except Exception as e:
        await asyncio.sleep(0.1)
        return await asyncio.to_thread(_fetch)

def group_emails_by_recipient(emails):
    """
    Group emails by the first recipient (converted to lower case).
    Returns a dictionary: { recipient_email: [msg, ...] }
    """
    groups = {}
    for msg in emails:
        if msg.to and len(msg.to) > 0:
            recipient = msg.to[0].lower()
            groups.setdefault(recipient, []).append(msg)
    return groups

def check_match(msg, alert_type):
    """
    Fuzzy matching for different alert types:
      - For "reset": returns True if the subject contains "password" and one of ["reset", "replacement"]
        and the email body has a Netflix link.
      - For "temp": returns True if the subject contains any word from TEMP_KEYWORDS and the body contains a temporary link.
      - For "code": returns True if the subject contains any word from CODE_KEYWORDS and the body contains a code.
    """
    subject = (msg.subject or "").lower()
    body = msg.text or ""
    if alert_type == "reset":
        if "password" in subject and any(kw in subject for kw in ["reset", "replacement"]) and extract_link(body):
            return True
    elif alert_type == "temp":
        if any(kw in subject for kw in TEMP_KEYWORDS) and extract_temp_link(body):
            return True
    elif alert_type == "code":
        if any(kw in subject for kw in CODE_KEYWORDS) and extract_code(body):
            return True
    return False

def get_result(msg, alert_type):
    """
    Extract and return the result (Netflix link or code) from the message.
    """
    body = msg.text or ""
    if alert_type == "reset":
        link = extract_link(body)
        if link:
            return f"üîó <b>Netflix Link:</b>\n{link}"
    elif alert_type == "temp":
        link = extract_temp_link(body)
        if link:
            return f"üîó <b>Netflix Link:</b>\n{link}"
    elif alert_type == "code":
        code = extract_code(body)
        if code:
            return f"üîë <b>Netflix Code:</b>\n<code>{code}</code>"
    return None

async def process_watchlist(attempt1_emails):
    """
    Process the watchlist by scanning each user‚Äôs emails from the shared ATTEMPT1 batch.
    For each user that does not match on attempt 1, schedule a retry.
    Returns a list of retry requests to be processed later.
    Each retry item is a tuple of (chat_id, user_email, alert_type, progress_msg, retry_start_time).
    """
    watchlist = load_watchlist()
    retry_requests = []
    for chat_id, user_data in watchlist.items():
        user_email = user_data["email"]
        # Determine the alert type based on provided filters.
        if "reset" in user_data["filters"]:
            alert_type = "reset"
        elif "temp" in user_data["filters"]:
            alert_type = "temp"
        else:
            alert_type = "code"
        start_time = datetime.now()
        progress_msg = await send_message(
            chat_id,
            f"‚è± [Attempt 1] Scanning {ATTEMPT1_LIMIT} emails for <b>{alert_type}</b> filter for <b>{user_email}</b>..."
        )
        groups1 = group_emails_by_recipient(attempt1_emails)
        user_msgs1 = groups1.get(user_email.lower(), [])
        total1 = len(user_msgs1)
        matched = False
        count = 0
        for msg in user_msgs1:
            count += 1
            elapsed = (datetime.now() - start_time).total_seconds()
            await update_message(chat_id, progress_msg.message_id,
                                 f"[Attempt 1] Processed {count}/{total1} emails for <b>{user_email}</b> (Elapsed: {elapsed:.1f}s)...")
            if await check_match_async(msg, alert_type):
                result = get_result(msg, alert_type)
                if result:
                    elapsed = (datetime.now() - start_time).total_seconds()
                    await update_message(chat_id, progress_msg.message_id,
                                         f"‚úÖ Match found in Attempt 1 (Elapsed: {elapsed:.1f}s):\n{result}")
                    log(f"User {user_email}: Match found in Attempt 1 after {elapsed:.1f}s.")
                    matched = True
                    break
        if not matched:
            await update_message(chat_id, progress_msg.message_id,
                                 f"‚ùå No match in Attempt 1 for <b>{user_email}</b>. Initiating retry...")
            log(f"User {user_email}: No match in Attempt 1, scheduled for retry.")
            # Record the request for retry processing.
            retry_requests.append((chat_id, user_email, alert_type, progress_msg, datetime.now()))
    # Clear the watchlist after processing attempt 1.
    save_watchlist({})
    return retry_requests

async def process_retries(retry_requests):
    """
    For all users scheduled for retry, fetch the latest ATTEMPT2_LIMIT emails once,
    then scan each user (using the shared set of attempt2 emails) so that if many users
    have emails in this batch, they all get updated instantly.
    """
    if not retry_requests:
        return
    attempt2_emails = await fetch_emails(ATTEMPT2_LIMIT)
    groups2 = group_emails_by_recipient(attempt2_emails)
    for chat_id, user_email, alert_type, progress_msg, retry_start in retry_requests:
        user_msgs2 = groups2.get(user_email.lower(), [])
        if user_msgs2:
            latest_msg = user_msgs2[0]
            await update_message(chat_id, progress_msg.message_id,
                                 f"[Attempt 2] Scanning the most recent email for <b>{user_email}</b>...")
            if await check_match_async(latest_msg, alert_type):
                result = get_result(latest_msg, alert_type)
                elapsed_retry = (datetime.now() - retry_start).total_seconds()
                if result:
                    await update_message(chat_id, progress_msg.message_id,
                                         f"‚úÖ Match found in Retry (Elapsed: {elapsed_retry:.1f}s):\n{result}")
                    log(f"User {user_email}: Match found in Attempt 2 (Retry) after {elapsed_retry:.1f}s.")
                else:
                    await update_message(chat_id, progress_msg.message_id,
                                         f"‚ùå No valid Netflix {alert_type} email found for <b>{user_email}</b> in Retry.")
                    log(f"User {user_email}: No match found in Retry.")
            else:
                await update_message(chat_id, progress_msg.message_id,
                                     f"‚ùå No valid Netflix {alert_type} email found for <b>{user_email}</b> in Retry.")
                log(f"User {user_email}: No match found in Retry.")
        else:
            await update_message(chat_id, progress_msg.message_id,
                                 f"‚ö†Ô∏è No emails found for <b>{user_email}</b> in Retry.")
            log(f"User {user_email}: No emails in Attempt 2.")

async def main():
    log("üöÄ Netflix multi-user advanced watcher started with optimized retry processing.")
    while True:
        try:
            # Fetch the latest ATTEMPT1_LIMIT emails (from the past day).
            attempt1_emails = await fetch_emails(ATTEMPT1_LIMIT)
            log(f"Shared ATTEMPT 1 emails fetched: {len(attempt1_emails)}")
            for email in attempt1_emails:
                log(f"Email subject: {email.subject}")
            
            # Process watchlist for attempt 1.
            retry_requests = await process_watchlist(attempt1_emails)
            
            # Process all retry requests concurrently using a single shared attempt 2 fetch.
            await process_retries(retry_requests)
        except Exception as e:
            log(f"‚ùó Error in main loop: {e}")
            reset_mailbox()
        # Wait for a short interval before polling again.
        await asyncio.sleep(SLEEP_INTERVAL)

if __name__ == "__main__":
    asyncio.run(main())