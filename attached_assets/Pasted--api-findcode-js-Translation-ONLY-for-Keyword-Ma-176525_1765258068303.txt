// ============================================
// api/findcode.js - Translation ONLY for Keyword Matching
// HTML remains original for Google Translate
// ============================================

import Imap from "imap";
import { simpleParser } from "mailparser";
import translatte from "translatte";

function escapeHtml(text) {
  if (!text) return '';
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function decodeHtmlEntities(html) {
  if (!html) return '';
  return html
    .replace(/&#x27;/g, "'")
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#x22;/g, '"')
    .replace(/&quot;/g, '"')
    .replace(/&#x26;/g, '&')
    .replace(/&amp;/g, '&')
    .replace(/&#x3C;/g, '<')
    .replace(/&lt;/g, '<')
    .replace(/&#x3E;/g, '>')
    .replace(/&gt;/g, '>')
    .replace(/&nbsp;/g, ' ');
}

// Translation ONLY for keyword detection (Python bot style)
async function translateForKeywordCheck(text) {
  if (!text || text.trim() === "") return text;
  
  try {
    // Short text - direct translation
    if (text.length < 500) {
      const result = await translatte(text, { to: "en" });
      return result.text;
    }
    
    // Long text - just take first 200 chars for keyword check
    const shortText = text.substring(0, 200);
    const result = await translatte(shortText, { to: "en" });
    return result.text;
  } catch (error) {
    console.log('Translation failed, using original:', error.message);
    return text;
  }
}

function hasAccountLink(htmlContent) {
  return /netflix\.com\/account/i.test(htmlContent);
}

// Python bot style: fuzzy keyword matching
async function isHouseholdEmail(originalSubject, htmlContent) {
  const originalLower = (originalSubject || "").toLowerCase();
  
  // English keywords for matching
  const englishKeywords = [
    "temporary",
    "household", 
    "temp",
    "home",
    "traveling",
    "travel",
    "access",
    "verify"
  ];
  
  // Check 1: Original subject (if already English)
  const hasKeywordInOriginal = englishKeywords.some(kw => originalLower.includes(kw));
  
  if (hasKeywordInOriginal) {
    const hasLink = hasAccountLink(htmlContent);
    console.log('✓ Keyword found in original subject:', originalSubject.substring(0, 60));
    return hasLink;
  }
  
  // Check 2: Translate subject and check again (Python bot approach)
  try {
    const translatedSubject = await translateForKeywordCheck(originalSubject);
    const translatedLower = translatedSubject.toLowerCase();
    
    console.log('Translated subject:', {
      original: originalSubject.substring(0, 50),
      translated: translatedSubject.substring(0, 50)
    });
    
    const hasKeywordInTranslated = englishKeywords.some(kw => translatedLower.includes(kw));
    
    if (hasKeywordInTranslated) {
      const hasLink = hasAccountLink(htmlContent);
      const matchedKeyword = englishKeywords.find(kw => translatedLower.includes(kw));
      
      console.log('✓ Keyword found after translation:', {
        keyword: matchedKeyword,
        hasLink: hasLink
      });
      
      return hasLink;
    }
  } catch (e) {
    console.log('Translation error, skipping:', e.message);
  }
  
  return false;
}

function getUserFriendlyError(error) {
  const errorMessage = error.message || error.toString();

  if (errorMessage.includes("AUTHENTICATIONFAILED") || errorMessage.includes("Invalid credentials")) {
    return "Email login failed. The email or password may be incorrect.";
  }
  if (errorMessage.includes("ENOTFOUND") || errorMessage.includes("getaddrinfo")) {
    return "Could not connect to email server. Please check your internet connection.";
  }
  if (errorMessage.includes("ETIMEDOUT") || errorMessage.includes("timeout")) {
    return "Connection timed out. Please try again.";
  }
  if (errorMessage.includes("ECONNREFUSED")) {
    return "Connection refused by email server. Please try again later.";
  }
  if (errorMessage.includes("certificate")) {
    return "Security certificate error. Please contact support.";
  }

  return "Something went wrong while searching emails. Please try again.";
}

function searchNetflixEmails(imapConfig, userEmail) {
  return new Promise((resolve, reject) => {
    const imap = new Imap(imapConfig);

    imap.once("ready", () => {
      imap.openBox("INBOX", true, (err, box) => {
        if (err) {
          imap.end();
          return reject(err);
        }

        // Python bot: 1 day ago
        const oneDayAgo = new Date();
        oneDayAgo.setDate(oneDayAgo.getDate() - 1);
        
        console.log('Searching emails since:', oneDayAgo.toISOString());
        console.log('User email:', userEmail);

        // IMAP search with date + FROM netflix
        imap.search([
          ['SINCE', oneDayAgo],
          ['FROM', 'netflix']
        ], (err, results) => {
          if (err) {
            console.error('IMAP search error:', err);
            imap.end();
            return reject(err);
          }

          console.log('Total Netflix emails found:', results ? results.length : 0);

          if (!results || results.length === 0) {
            imap.end();
            return resolve([]);
          }

          // Latest 200 emails
          const latestEmails = results.slice(-200);
          console.log('Fetching latest', latestEmails.length, 'emails');

          const fetch = imap.fetch(latestEmails, { bodies: "", struct: true });
          const emailPromises = [];

          fetch.on("message", (msg, seqno) => {
            const emailPromise = new Promise((resolveEmail) => {
              let emailData = null;

              msg.on("body", (stream, info) => {
                simpleParser(stream, (err, parsed) => {
                  if (err) {
                    resolveEmail(null);
                    return;
                  }
                  emailData = parsed;
                });
              });

              msg.once("end", () => {
                setTimeout(() => resolveEmail(emailData), 100);
              });
            });
            emailPromises.push(emailPromise);
          });

          fetch.once("error", (err) => {
            console.error('Fetch error:', err);
            imap.end();
            reject(err);
          });

          fetch.once("end", async () => {
            try {
              const emails = await Promise.all(emailPromises);
              const validEmails = emails.filter(e => e !== null);
              console.log('Total emails parsed:', validEmails.length);

              const userEmailLower = userEmail.toLowerCase().trim();

              // Python bot style: Group by first recipient
              const groupedByRecipient = {};
              for (const email of validEmails) {
                if (email.to && email.to.length > 0) {
                  // Get the actual email address (not display name)
                  const firstRecipient = email.to[0];
                  const recipientEmail = firstRecipient.address ? firstRecipient.address.toLowerCase() : firstRecipient.toLowerCase();
                  
                  if (!groupedByRecipient[recipientEmail]) {
                    groupedByRecipient[recipientEmail] = [];
                  }
                  groupedByRecipient[recipientEmail].push(email);
                }
              }

              console.log('Total unique recipients:', Object.keys(groupedByRecipient).length);
              console.log('First 5 recipients:', Object.keys(groupedByRecipient).slice(0, 5));

              const userEmails = groupedByRecipient[userEmailLower] || [];
              console.log('Emails for user', userEmailLower, ':', userEmails.length);

              if (userEmails.length === 0) {
                console.log('❌ No emails found for this user');
                console.log('Available recipients:', Object.keys(groupedByRecipient).slice(0, 10));
                
                // Debug: Check if email exists in any field
                const foundInOtherFields = validEmails.filter(e => {
                  const htmlContent = (e.html || "").toLowerCase();
                  const textContent = (e.text || "").toLowerCase();
                  return htmlContent.includes(userEmailLower) || textContent.includes(userEmailLower);
                });
                
                if (foundInOtherFields.length > 0) {
                  console.log('⚠️ Found', foundInOtherFields.length, 'emails with user email in HTML/Text but not in To field');
                }
                
                imap.end();
                resolve([]);
                return;
              }

              // Sort by date (newest first)
              const sortedEmails = userEmails.sort((a, b) => new Date(b.date) - new Date(a.date));

              imap.end();

              let householdEmail = null;

              // Check emails - translate subject for keyword matching
              for (const email of sortedEmails) {
                const subject = email.subject || "";
                const htmlContent = email.html || "";

                console.log('Checking email:', {
                  subject: subject.substring(0, 60),
                  date: email.date ? new Date(email.date).toISOString() : 'no date'
                });

                // TRANSLATE SUBJECT + CHECK KEYWORDS (Python bot approach)
                if (await isHouseholdEmail(subject, htmlContent)) {
                  householdEmail = email;
                  console.log('✓ Found household email!');
                  break;
                }
              }

              if (!householdEmail) {
                console.log('❌ No household email found');
                console.log('Checked', sortedEmails.length, 'emails');
                
                // Debug: Show first 3 subjects
                if (sortedEmails.length > 0) {
                  console.log('First 3 email subjects:');
                  sortedEmails.slice(0, 3).forEach((e, i) => {
                    console.log(`${i + 1}. ${e.subject}`);
                  });
                }
                
                resolve([]);
                return;
              }

              // Return ORIGINAL HTML (no translation)
              // Google Translate will handle frontend translation
              const htmlContent = householdEmail.html || "";
              const decodedHtml = decodeHtmlEntities(htmlContent);

              const formattedEmail = {
                id: householdEmail.messageId || `${Date.now()}-${Math.random()}`,
                subject: decodeHtmlEntities(householdEmail.subject || "Netflix Email"),
                receivedAt: householdEmail.date ? householdEmail.date.toISOString() : new Date().toISOString(),
                from: householdEmail.from?.text || "",
                to: householdEmail.to?.text || "",
                // ORIGINAL HTML - Google Translate করবে frontend এ
                rawHtml: `<div class="netflix-email-original">${decodedHtml}</div>`,
              };

              console.log('✓ Returning email:', formattedEmail.subject);
              resolve([formattedEmail]);
            } catch (parseError) {
              console.error('Parse error:', parseError);
              imap.end();
              reject(parseError);
            }
          });
        });
      });
    });

    imap.once("error", (err) => {
      console.error('IMAP connection error:', err);
      reject(err);
    });

    imap.connect();
  });
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { email } = req.body;

  if (!email) {
    return res.status(400).json({ error: "Please enter an email address to search." });
  }

  const imapConfig = {
    user: process.env.EMAIL_ADDRESS,
    password: process.env.EMAIL_PASSWORD,
    host: process.env.EMAIL_SERVER || "imap.gmail.com",
    port: parseInt(process.env.EMAIL_PORT || "993", 10),
    tls: process.env.EMAIL_TLS !== "false",
    tlsOptions: { rejectUnauthorized: false },
  };

  if (!imapConfig.user || !imapConfig.password) {
    return res.status(500).json({ 
      error: "Email service is not configured. Please contact the administrator." 
    });
  }

  try {
    const results = await searchNetflixEmails(imapConfig, email);
    if (results && results.length > 0) {
      res.status(200).json({ emails: results, totalCount: results.length });
    } else {
      res.status(404).json({ 
        error: "No Netflix email found for this address." 
      });
    }
  } catch (error) {
    res.status(500).json({ 
      error: getUserFriendlyError(error)
    });
  }
}